<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æŒ‡å°–é­”æ³• - çƒŸèŠ±ä¸æµå…‰</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020202; /* ææ·±ç°é»‘ï¼Œæ¯”çº¯é»‘æ›´æœ‰è´¨æ„Ÿ */
            touch-action: none;
            cursor: none; /* éšè—é¼ æ ‡ */
        }
        canvas {
            display: block;
        }
        .hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Microsoft YaHei', sans-serif;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            text-align: center;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
            animation: pulse 2s infinite;
            z-index: 10;
        }
        /* è®©æ–‡å­—é—ªçƒä¸€ä¸‹ç„¶åæ¶ˆå¤± */
        .hint.fade {
            transition: opacity 2s;
            opacity: 0;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>

    <div class="hint" id="hint">ç‚¹ä¸€ç‚¹ï¼šæ”¾çƒŸèŠ± ğŸ’¥<br>æ»‘ä¸€æ»‘ï¼šå†™åå­— âœ¨</div>
    <canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const hint = document.getElementById('hint');

    // 3ç§’åéšè—æç¤ºæ–‡å­—
    setTimeout(() => {
        hint.classList.add('fade');
    }, 3000);

    let width, height;
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // æ ¸å¿ƒå˜é‡
    let particles = [];
    let hue = 0;
    
    // é¼ æ ‡/è§¦æ‘¸é€»è¾‘
    const mouse = { x: undefined, y: undefined };
    const lastMouse = { x: undefined, y: undefined };
    let isDrawing = false;

    // --- ç²’å­ç³»ç»Ÿ ---
    class Particle {
        // isExplosion: true=çˆ†ç‚¸çƒŸèŠ±, false=æ‹–å°¾æµå…‰
        constructor(x, y, hue, isExplosion) {
            this.x = x;
            this.y = y;
            this.isExplosion = isExplosion;
            
            // é¢œè‰²ç­–ç•¥
            const colorVar = Math.random() * 60 - 30;
            // çˆ†ç‚¸æ—¶é¢œè‰²æ›´äº®ï¼Œæ‹–å°¾æ—¶æœ‰ä¸€åŠæ˜¯ç™½è‰²
            if (isExplosion) {
                // çˆ†ç‚¸å…¨æ˜¯å½©è‰²ï¼Œä¸”äº®åº¦é«˜
                this.color = `hsl(${hue + colorVar}, 100%, 60%)`;
                this.size = Math.random() * 3 + 1; // çˆ†ç‚¸ç²’å­ç¨å¤§
                this.decay = Math.random() * 0.015 + 0.01; // æ¶ˆå¤±æ…¢ä¸€ç‚¹
            } else {
                // æ‹–å°¾
                this.color = Math.random() > 0.5 ? `hsl(${hue + colorVar}, 100%, 70%)` : '#fff'; 
                this.size = Math.random() * 2 + 0.5;
                this.decay = Math.random() * 0.02 + 0.015;
            }

            // ç‰©ç†å±æ€§ï¼šçˆ†ç‚¸è¦å¿«ï¼Œæ‹–å°¾è¦æ…¢
            const angle = Math.random() * Math.PI * 2;
            let speed;
            
            if (isExplosion) {
                // çˆ†ç‚¸é€Ÿåº¦å¿«ï¼ŒèŒƒå›´å¤§
                speed = Math.random() * 10 + 2; 
                this.gravity = 0.15; // çˆ†ç‚¸åä¸‹å æ„Ÿæ˜æ˜¾
                this.friction = 0.96;
            } else {
                // æ‹–å°¾é€Ÿåº¦æ…¢ï¼Œèšæ‹¢
                speed = Math.random() * 1.5 + 0.2; 
                this.gravity = 0.02; // å‡ ä¹é£˜åœ¨ç©ºä¸­
                this.friction = 0.95;
            }
            
            this.speedX = Math.cos(angle) * speed;
            this.speedY = Math.sin(angle) * speed;
            this.life = 1;
        }

        update() {
            this.speedX *= this.friction;
            this.speedY *= this.friction;
            this.speedY += this.gravity;
            this.x += this.speedX;
            this.y += this.speedY;
            this.life -= this.decay;
        }

        draw() {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // --- åŠŸèƒ½1ï¼šç‚¹å‡»äº§ç”Ÿçˆ†ç‚¸ ---
    function createExplosion(x, y) {
        const particleCount = 80; // çˆ†ç‚¸ç²’å­æ•°é‡
        for (let i = 0; i < particleCount; i++) {
            particles.push(new Particle(x, y, hue, true)); // true = çˆ†ç‚¸æ¨¡å¼
        }
    }

    // --- åŠŸèƒ½2ï¼šæ»‘åŠ¨äº§ç”Ÿæ‹–å°¾ï¼ˆæ’å€¼ç®—æ³•ï¼‰ ---
    function createTrail(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const stepSize = 4; // å¯†åº¦
        const steps = distance / stepSize;

        for (let i = 0; i <= steps; i++) {
            const x = x1 + (dx / steps) * i;
            const y = y1 + (dy / steps) * i;
            // æ¯ä¸ªç‚¹ç”Ÿæˆ2ä¸ªç²’å­
            for(let k=0; k<2; k++){
                particles.push(new Particle(x, y, hue, false)); // false = æ‹–å°¾æ¨¡å¼
            }
        }
    }

    function animate() {
        // 1. è®¾ç½®ç”»å¸ƒèƒŒæ™¯ï¼Œäº§ç”Ÿé•¿æ‹–å°¾æ•ˆæœ
        // å¦‚æœæƒ³æ‹–å°¾æ›´é•¿ï¼ŒæŠŠ 0.1 æ”¹æˆ 0.05
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'; 
        ctx.fillRect(0, 0, width, height);

        // 2. å¼€å¯å‘å…‰æ¨¡å¼
        ctx.globalCompositeOperation = 'lighter';

        // 3. æ›´æ–°æ‰€æœ‰ç²’å­
        for (let i = 0; i < particles.length; i++) {
            particles[i].update();
            particles[i].draw();

            if (particles[i].life <= 0) {
                particles.splice(i, 1);
                i--;
            }
        }

        hue += 1; // æ•´ä½“é¢œè‰²æµè½¬
        requestAnimationFrame(animate);
    }

    // --- äº‹ä»¶ç›‘å¬ ---

    // å¼€å§‹ï¼ˆæŒ‰ä¸‹ï¼‰
    function onStart(x, y) {
        isDrawing = true;
        lastMouse.x = x;
        lastMouse.y = y;
        mouse.x = x;
        mouse.y = y;
        
        // é‡ç‚¹ï¼šæŒ‰ä¸‹ç¬é—´ï¼Œç›´æ¥ç‚¸å¼€ï¼ğŸ’¥
        createExplosion(x, y);
        // åŒæ—¶ä¹Ÿäº§ç”Ÿä¸€ç‚¹æ‹–å°¾èµ·å§‹ç‚¹
        createTrail(x, y, x, y);
    }

    // ç§»åŠ¨ï¼ˆæ‹–åŠ¨ï¼‰
    function onMove(x, y) {
        if (!isDrawing) return;
        createTrail(lastMouse.x, lastMouse.y, x, y);
        lastMouse.x = x;
        lastMouse.y = y;
    }

    // ç»“æŸï¼ˆæ¾å¼€ï¼‰
    function onEnd() {
        isDrawing = false;
        lastMouse.x = undefined;
        lastMouse.y = undefined;
    }

    // é€‚é…é¼ æ ‡
    canvas.addEventListener('mousedown', e => onStart(e.clientX, e.clientY));
    canvas.addEventListener('mousemove', e => onMove(e.clientX, e.clientY));
    canvas.addEventListener('mouseup', onEnd);

    // é€‚é…è§¦å± (æ”¯æŒå¤šç‚¹è§¦æ§çˆ†ç‚¸)
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.touches.length; i++) {
            const t = e.touches[i];
            // å¯¹æ¯ä¸ªæ–°æŒ‰ä¸‹çš„æ‰‹æŒ‡éƒ½äº§ç”Ÿçˆ†ç‚¸
            // è¿™é‡Œç®€å•å¤„ç†ï¼šä»¥ç¬¬ä¸€ä¸ªæ‰‹æŒ‡ä¸ºæ‹–å°¾ä¸»æ§ï¼Œä½†æ‰€æœ‰æ‰‹æŒ‡éƒ½èƒ½è§¦å‘ç‚¹å‡»çˆ†ç‚¸
            if (i === 0) onStart(t.clientX, t.clientY);
            else createExplosion(t.clientX, t.clientY);
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        // åªè·Ÿéšç¬¬ä¸€æ ¹æ‰‹æŒ‡ç”»çº¿ï¼Œé˜²æ­¢è¿‡äºæ··ä¹±
        onMove(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});
    
    canvas.addEventListener('touchend', onEnd);

    animate();
</script>
</body>
</html>